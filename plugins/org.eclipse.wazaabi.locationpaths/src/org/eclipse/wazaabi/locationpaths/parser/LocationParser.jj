options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  JDK_VERSION = "1.4";}PARSER_BEGIN(LocationParser)/******************************************************************************* * Copyright (c) 2010 Olivier Moises * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *   Olivier Moises- initial API and implementation *******************************************************************************/package org.eclipse.wazaabi.locationpaths.parser;import java.util.ArrayList;import org.eclipse.wazaabi.locationpaths.model.Axis;import org.eclipse.wazaabi.locationpaths.model.Expression;import org.eclipse.wazaabi.locationpaths.model.BinaryExpression;import org.eclipse.wazaabi.locationpaths.model.EqualityExpression;import org.eclipse.wazaabi.locationpaths.model.Operator;import org.eclipse.wazaabi.locationpaths.model.IntegerExpression;import org.eclipse.wazaabi.locationpaths.model.LiteralExpression;import org.eclipse.wazaabi.locationpaths.model.LocationPath;import org.eclipse.wazaabi.locationpaths.model.Step;import org.eclipse.wazaabi.locationpaths.model.InitialContext;import org.eclipse.wazaabi.locationpaths.model.QueryContext;public class LocationParser{}PARSER_END(LocationParser)LocationPath LocationPath() :{  LocationPath locationPath = new LocationPath();  InitialContext initialContext = null;}{  (    LOOKAHEAD(2)    (      initialContext = InitialContext()      (        < SLASH > RelativeLocationPath(locationPath)      )?    )  | RelativeLocationPath(locationPath)  )  {    if (initialContext != null) locationPath.setInitialContext(initialContext);    return locationPath;  }}LocationPath RelativeLocationPath(LocationPath locationPath) :{}{  (    NodeTest(locationPath)    (      LocationStep(locationPath)    )*  )  {    return locationPath;  }}InitialContext InitialContext() :{  InitialContext initialContext = null;}{  (    initialContext = QueryContext()  )  {    return initialContext;  }}void LocationStep(LocationPath locationPath) :{}{  (    < SLASH >  | < SLASHSLASH >    {      Step step = new Step();      step.setAxis(Axis.DESCENDANT_OR_SELF);      step.setNameTest(null);      locationPath.getSteps().add(step);    }  )  NodeTest(locationPath)}String WildcardName() :{}{  (    "*"  | < IDENTIFIER >  )  {    return (String) token.image;  }  {}}void NodeTest(LocationPath locationPath) :{  int axis;  int type =-1;  String name = null;  Expression p;  Step step = new Step();}{  (    (      axis = AxisSpecifier()      (        LOOKAHEAD(NodeType() "(" ")")        type = NodeType() "(" ")"      | name = WildcardName()      )    | "."      {        axis = Axis.SELF;      }    | ".."      {        axis = Axis.PARENT;      }    )    (      p = Predicate()      {        step.getPredicates().add(p);      }    )*  )  {    step.setAxis(axis);    if (name != null) step.setNameTest(name);    locationPath.getSteps().add(step);  }}int NodeType() :{  int type;}{  (< NODE >  {    type = 1;  }  )  {    return type;  }}int AxisSpecifier() :{  int axis;}{  (    axis = AxisName()  | axis = AbbreviatedAxisSpecifier()  )  {    return axis;  }}int AbbreviatedAxisSpecifier() :{  int axis = Axis.CHILD;}{  (    (      "@"      {        axis = Axis.ATTRIBUTE;      }    | "&"      {        axis = Axis.REFERENCE;      }    | "$"      {        axis = Axis.VARIABLE;      }    )  )?  {    return axis;  }}int AxisName() :{  int axis;}{  (    < AXIS_SELF >    {      axis = Axis.SELF;    }  | < AXIS_CHILD >    {      axis = Axis.CHILD;    }  | < AXIS_ATTRIBUTE >    {      axis = Axis.ATTRIBUTE;    }  | < AXIS_REFERENCE >    {      axis = Axis.REFERENCE;    }  | < AXIS_VARIABLE >    {      axis = Axis.VARIABLE;    }  | < AXIS_DESCENDANT_OR_SELF >    {      axis = Axis.DESCENDANT_OR_SELF;    }  | < AXIS_PARENT >    {      axis = Axis.PARENT;    }  | < AXIS_CLASS >    {      axis = Axis.CLASS;    }  | < AXIS_PACKAGE >    {      axis = Axis.PACKAGE;    }  )  {    return axis;  }}Expression Predicate() :{  Expression ex = null;}{  "[" ex = Expression() "]"  {    return ex;  }}Expression Expression() :{  Expression ex;}{  ex = OrExpr()  {    return ex;  }}Expression PrimaryExpr() :{  Expression ex = null;}{  (    < Literal >    {      ex = new LiteralExpression();      ((LiteralExpression) ex).setValue(token.image.substring(1, token.image.length() - 1));    }  | < Number >    {      ex = new IntegerExpression();      ((IntegerExpression) ex).setValue(Integer.parseInt(token.image));    }    //   |    LOOKAHEAD(CoreFunctionName() "(") ex = CoreFunctionCall()    //   |    ex = FunctionCall()  )  {    return ex;  }}Expression FilterExpr() :{  Expression ex, p;  ArrayList ps = new ArrayList();  boolean path = false;  LocationPath locationPath = new LocationPath();  ArrayList steps = new ArrayList();}{  (    ex = PrimaryExpr()    (      p = Predicate()      {        path = true;        ps.add(p);      }    )*    (      LocationStep(locationPath)      {        path = true;      }    )*  )  {    if (path)    { /*return compiler.expressionPath(ex, ps.toArray(), steps.toArray());*/}    else    {      return ex;    }  }}Expression OrExpr() :{  Expression ex, r = null;}{  (    ex = AndExpr()    (      < OR > r = AndExpr()    )*  )  {    if (r == null) return ex;    else    {      return new BinaryExpression(ex, r, Operator.OR);    }  }}Expression AndExpr() :{  Expression ex, r = null;}{  (    ex = EqualityExpr()    (      < AND > r = EqualityExpr()    )*  )  {    if (r == null) return ex;    else    {      return new BinaryExpression(ex, r, Operator.AND);    }  }}Expression EqualityExpr() :{  Expression ex, r, tmp;}{  (    ex = PathExpr()    (      (        < EQ > r = PathExpr()        {          ex = new EqualityExpression(ex, r, Operator.EQUAL);        }      | < NEQ > r = PathExpr()        {          ex = new EqualityExpression(ex, r, Operator.NOT_EQUAL);        }      )    )*  )  {    return ex;  }}Expression PathExpr() :{  Expression ex = null;  Object [ ] steps;}{  (    // Reason for LOOKAHEAD:    // foo:bar()  - filter path    // foo:bar    - location path    LOOKAHEAD(PrimaryExpr())    ex = FilterExpr()  | ex = LocationPath()  )  {    return ex;  }}QueryContext QueryContext() :{  String name;  ArrayList args;  QueryContext queryContext = new QueryContext();}{  name = FunctionName() args = ArgumentList()  {    if (args != null)    {      queryContext.setArgs(args);    }  }  {    queryContext.setFunctionName(name);    return queryContext;  }}String FunctionName() :{  String qname;}{  qname = Identifier_Without_CoreFunctions()  {    return qname;  }}String Identifier() :{}{  (    Identifier_Without_CoreFunctions()  | < NODE >  )  {    return token.image;  }}String Identifier_Without_CoreFunctions() :{}{  (    < IDENTIFIER >  | < OR >  | < AND >  | < MOD >  | < DIV >  )  {    return token.image;  }}ArrayList ArgumentList() :{  ArrayList args = null;  Object arg;}{  "("  (    arg = Argument()    {      args = new ArrayList();      args.add(arg);    }    (      "," arg = Argument()      {        args.add(arg);      }    )*  )?  ")"  {    return args;  }}Object Argument() :{  Object ex;}{  ex = Expression()  {    return ex;  }}SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}TOKEN :{  < AXIS_SELF : "self::" >| < AXIS_CHILD : "child::" >| < AXIS_ATTRIBUTE : "attribute::" >| < AXIS_REFERENCE : "reference::" >| < AXIS_VARIABLE : "variable::" >| < AXIS_DESCENDANT_OR_SELF : "descendant-or-self::" >| < AXIS_PARENT : "parent::" >| < AXIS_CLASS : "class::" >| < AXIS_PACKAGE : "package::" >| < NODE : "node" >| < OR : "or" >| < AND : "and" >| < MOD : "mod" >| < DIV : "div" >}TOKEN :{  < IDENTIFIER : < LETTER > (< PART_LETTER >)* >| < #LETTER : [ "A"-"Z", "_", "a"-"z" ] >| < #PART_LETTER : [ "$", "A"-"Z", "_", "a"-"z", "0"-"9" ] >}TOKEN :{  < SLASH : "/" >| < SLASHSLASH : "//" >| < EQ : "=" >| < NEQ : "!=" >  /*| < VARIABLE : "$" >*/}TOKEN :{  < Literal :    "\"" (~[ "\"" ])* "\""  | "'" (~[ "'" ])* "'" >| < #Digit : [ "0"-"9" ] >| < Number :    (< Digit >)+    (      (< Digit >)+    )? >}